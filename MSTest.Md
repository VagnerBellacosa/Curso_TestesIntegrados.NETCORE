# MSTEST 

**MSTest** √© uma ferramenta da Microsoft utilizada para executar teste por linha comando.

Ap√≥s criarmos nossos testes e su√≠tes de testes utilizando o Visual Studio, podemos criar rotinas de testes usando Prompt de Comando e execut√°-las utilizando o MSTEST. Tamb√©m podemos realizar integra√ß√µes com algumas API‚Äôs para criar rotinas na qual demonstramos nossos resultados

## Testes de Unidade

Testes de unidade n√£o s√£o um artefato comum no cen√°rio de desenvolvimento de software corporativo, todos j√° ouviram falar, alguns tentam colocar em pr√°tica mas a quest√£o da falta de design de c√≥digo acaba n√£o permitindo.

Al√©m disso existem os famosos gestores que inibem a pr√°tica, pois acreditam que escrever um c√≥digo para testar outro c√≥digo √© perda de tempo e aumenta o tempo de projeto.

TDD? Isso √© coisa de Jedi! Apenas os desenvolvedores mais graduados na arte da codifica√ß√£o s√£o capazes de escrever o teste de um c√≥digo que ainda n√£o existe.

N√£o √© bem por ai!
Testes de unidade fazem parte da tarefa de escrever c√≥digo! C√≥digo bom √© aquele que pode ser testado. O que vale mais? Rodar a aplica√ß√£o at√© o ponto desejado, colocar um break point no c√≥digo e validar linha a linha se o c√≥digo est√° realmente cumprindo a necessidade ou escrever um teste que valide isto?

Al√©m do teste lhe prover um feedback em milissegundos, voc√™ s√≥ precisa escrever ele uma vez. Rodar a aplica√ß√£o e realizar o debug pode demorar minutos e este tipo de valida√ß√£o precisa ser repetida dezenas de vezes (ou at√© mais).

TDD n√£o √© a uma t√©cnica complicada, pelo contr√°rio, √© simples! N√£o existem motivos para n√£o testar, na verdade muitos problemas do dia-a-dia seriam evitados com os testes.

## Ent√£o por que n√£o testamos?

Acredito que o principal fator √© que o desenvolvedor n√£o sabe testar! Como eu costumo dizer, isto √© uma quest√£o de ‚Äútooling‚Äù. Tooling seria o ferramental, a pr√°tica necess√°ria e ferramentas utilizadas para a escrita de testes de unidade.

- Meu objetivo n√£o √© provar que testes de unidade v√£o resolver muitos dos seus problemas e melhorar a qualidade das suas entregas (mas v√£o sim, acredite).

- Meu objetivo √© apresentar um √≥timo conjunto de ferramentas para que voc√™ comece a escrever testes de unidade da melhor forma poss√≠vel!

Todas as ferramentas s√£o open-source e gratuitas üòâ

## Frameworks de Testes

S√£o os respons√°veis por rodar os testes de unidade e fazer as asser√ß√µes (Assert) para garantir que o resultado do teste bateu com o esperado.

√â a ferramenta mais importante e √© necess√°rio fazer uma boa escolha, afinal depois de ter escrito centenas de testes mudar de framework n√£o ser√° simples.

Para .NET n√£o temos tantas op√ß√µes (ainda bem)

- MSTest
- NUnit
- XUnit

O **MSTest** √© o framework padr√£o do Visual Studio, desenvolvido pela Microsoft e utilizado em muitos projetos. Eu n√£o costumo utilizar, mas tamb√©m n√£o o julgo como ruim.

O **NUnit** √© o framework mais utilizado entre desenvolvedores .NET, possui anos de hist√≥ria e atende muito bem as necessidades, podemos ver o NUnit como uma portabilidade do JUnit do Java para .NET.

**XUnit** √© o mais novo desta lista e atualmente meu preferido. Ele foi criado pelos mesmos desenvolvedores do NUnit. A ideia do XUnit surgiu em simplificar e modernizar a forma de escrever testes. Estas mudan√ßas seriam imposs√≠veis de serem aplicadas no NUnit, pois resultaria num gigantesco breaking change nos testes j√° existentes.

Mas esse XUnit √© confi√°vel mesmo? Os desenvolvedores do novo stack do .NET est√£o utilizando o XUnit. Sim o nosso .NET Core, ASP.NET Core, EF Core, etc est√£o sendo testados com XUnit. Acho que somente este fato j√° nos tr√°s bastante seguran√ßa certo?

### Um pouco mais sobre o XUnit

Escrever testes com o XUnit √© um pouco diferente, afinal algumas coisas fogem do padr√£o, n√£o √© necess√°rio fazer Setup, Tear Down etc, basta usar o construtor da clase e o dispose. √â um framework muito flex√≠vel e √© poss√≠vel criar extens√µes para diversas finalidades.

Eu sugiro que voc√™ leia a compara√ß√£o feita entre o XUnit e os outros frameworks para come√ßar a ter uma ideia das mudan√ßas. N√£o deixe tamb√©m de ler a documenta√ß√£o e visitar o projeto no GitHub.

Para que o Visual Studio reconhe√ßa seus testes (uma vez que √© o MSTest o padr√£o) √© necess√°rio instalar um ‚ÄúRunner‚Äú, existem runners para Visual Studio, Xamarin, Console, MSBuild e etc.

Eu preparei um projeto implementando todas as ferramentas listadas e com exemplos de como utilizar. O link est√° no final do post (mas continue lendo, tem muito mais).

## Frameworks de Mock
O que seriam dos testes sem os Mocks? Para quem n√£o conhece o termo, realizar o Mock de algo √© criar em tempo de execu√ß√£o uma inst√¢ncia de uma classe ou a implementa√ß√£o de uma interface. Imagine que seu teste depende de ler algo do banco de dados, voc√™ n√£o precisa que ele v√° at√© o banco de fato, basta ‚Äúfingir‚Äù que foi.

O Mock √© uma inst√¢ncia de determinado objeto mas n√≥s podemos ensinar este objeto ‚Äúmockado‚Äù a responder conforme nossas necessidades, por exemplo ao inv√©s de ir at√© o banco simplemente traga uma lista de objetos que j√° foi definida como retorno. Para isto basta ‚Äúensinar‚Äù o m√©todo do objeto mockado o que ele deve fazer ao ser invocado.

### Para Mock tamb√©m existem algumas op√ß√µes:

- RhinoMocks
- MOQ
- NSubstitute
- FakeItEasy

Existem mais op√ß√µes al√©m dos listados, estes s√£o os mais utilizados atualmente.

O meu preferido e o que utilizo atualmente √© o MOQ.

#### Este MOQ √© o melhor? Devo-utilizar?

N√£o existe o melhor, √© quest√£o de afinidade tamb√©m, mas com certeza o MOQ √© um dos melhores e temos mais uma vantagem. A Microsoft utiliza o MOQ junto com o XUnit para desenvolver nosso novo stack do .NET Core.

##### Um exemplo de Mock com MOQ

Vamos simular que desejamos validar o retorno de um objeto que seria recuperado do banco de dados atrav√©s de um reposit√≥rio.

[Fact]
public void CustomerRepository_GetCustomer_ShouldReturnUniqueCustomer(){

    // Arrange

    var customer = new Customer(Guid.NewGuid(),

                                "Eduardo Pires");

    var repository = new Mock<ICustomerRepository>();
    repository.Setup(r => r.GetById(customer.Id))
        .Returns(customer);
    // Act
    var customerRet = repository.Object.GetById(customer.Id);
    // Assert
    Assert.Equal(customer, customerRet);
    repository.Verify(r => r.GetById(It.IsAny<Guid>()),
                           Times.Once);
}

Criamos uma inst√¢ncia do objeto baseado na interface, ‚Äúensinamos‚Äù ao m√©todo o que ele devolveria retornar ao receber determinado par√¢metro e pronto.

O MOQ ainda nos oferece o Verify que √© um m√©todo de Asser√ß√£o para validarmos se aquele m√©todo foi realmente chamado e quantas vezes foi.

Poder√≠amos ter parado por aqui, pois apenas um bom framework de teste e um de mock j√° nos bastariam para escrever nossos testes de unidade, mas tem como melhorar bastante esta experi√™ncia.

## Apresentando o AutoMoq

Imagine que voc√™ precisa criar a inst√¢ncia de um objeto mas este objeto recebe diversas depend√™ncias injetadas no construtor. Obviamente no teste voc√™ n√£o ter√° um container de DI, nesse caso voc√™ precisaria criar um mock de cada depend√™ncia e depois passar todas no construtor.

Tranquilo! Mas d√° para ser melhor! E se fosse poss√≠vel criar de uma vez s√≥ este objeto com todos os mocks gerados e injetados? Pouparia bastante c√≥digo n√©?

√â para isto que existe o AutoMoq! Sim voc√™ vai querer muito ele em seu projeto.

O AutoMoq gera os mocks do MOQ, est√° tudo em casa!

A classe CustomerService possui duas depend√™ncias injetadas no construtor


public class CustomerService : ICustomerService{
    private readonly ICustomerRepository _customerRepository;
    private readonly IMediator _mediator;
    public CustomerService(
                ICustomerRepository customerRepository,
                IMediator mediator){
        _customerRepository = customerRepository;
        _mediator = mediator;
    }
}

Vamos criar uma inst√¢ncia dela e automaticamente seus mocks com o AutoMoq

[Fact]
public void CustomerService_RegisterNewCustomer_ShouldRegisterWithSuccess()
{
    // Arrange
    var customer = new Customer(Guid.NewGuid(),
        "Eduardo Pires");
 
    var mocker = new AutoMoqer();
    mocker.Create<CustomerService>();
    var customerService = mocker.Resolve<CustomerService>();
    var repository = mocker.GetMock<ICustomerRepository>();
    // Act
    customerService.Register(customer);
    // Assert
    repository.Verify(r => r.Add(It.IsAny<Customer>()),
                           Times.Once);
}

Note de que al√©m de criar o objeto com seus mocks injetados √© poss√≠vel ainda obter estes mocks para que possam ser ‚Äúensinados‚Äù ou apenas validados como no caso do nosso teste, isso significa que o reposit√≥rio salvou o cliente, logo podemos entender que o teste conseguiu validar o processo.

O AutoMoq √© indispens√°vel para nos poupar da tarefa de criar e injetar cada mock e √© basicamente isto que ele faz.

#### Bogus

Voc√™ j√° deve ter imaginado que √© muito chato ter que ficar criando dados de testes (e-mails, telefone, nome, sobrenome, endere√ßo etc). Al√©m disso muitas vezes √© necess√°rio simular uma grande lista de dados √∫nicos. Como fazer?

O Bogus √© um gerador de dados aleat√≥rios! Existem outros que fazem isto, mas o Bogus √© mais humano. Ele gera dados reais e em diversos idiomas \o/

Vamos simular que desejo criar uma lista de 100 clientes

var customerTests = new Faker<Customer>("pt-BR")
    .CustomInstantiator(f => new Customer(
        Guid.NewGuid(),
        f.Name.FirstName(Name.Gender.Male),
        f.Name.LastName(Name.Gender.Male),
        f.Date.Past(80, DateTime.Now.AddYears(-18)),
        f.Internet.Email().ToLower(),
        true,
        DateTime.Now)).Generate(100);

O resultado √© muito interessante! Dados humanos gerados com muita facilidade e a garantia de unicidade. Note que n√£o √© problema criar um objeto que depende de um construtor.

#### Bogus Random Data

Uma grande chatea√ß√£o a menos! O Bogus √© capaz de gerar diversos tipos de informa√ß√µes e at√© imagens, recomendo que leia a documenta√ß√£o.

##### FluentAssertions

√â a asser√ß√£o que garante o resultado do teste, os frameworks tradicionais possuem uma s√©rie de m√©todos para validar se √© igual, verdadeiro, falso, maior, menor e etc. Mas a escrita de diversos Asserts pode ser chata e deixar o c√≥digo inexpress√≠vel.

O Fluent Assertions pode te ajudar nisto! Al√©m de utilizar a sintaxe fluente existem in√∫meros tipos de asser√ß√µes que podem ser feitas deixando nosso c√≥digo mais reduzido e f√°cil de entender.

1
[Fact]
2
public void CustomerService_GetAllActive_ShouldReturnsOnlyActiveCustomers()
3
{
4
    // Arrange
5
    var customerService = Fixture.GetCustomerService();
6
    Fixture.CustomerRepositoryMock.Setup(c => c.GetAll())
7
        .Returns(Fixture.GetMixedCustomers());
8
 
9
    // Act
10
    var customers = customerService.GetAllActive().ToList();
11
 
12
    // Assert Fluent Assertions
13
    customers.Should().HaveCount(c => c > 1)
14
        .And.OnlyHaveUniqueItems();
15
 
16
    customers.Should().NotContain(c => !c.Active);
17
}
√â poss√≠vel mesclar diversas asser√ß√µes em uma √∫nica linha de c√≥digo.
Bonito n√©? N√£o deixe de conferir a documenta√ß√£o.

Outras ferramentas
O meu set b√°sico √© este, por√©m contamos com outras ferramentas como por exemplo o AutoFixture que facilita a cria√ß√£o de objetos comumente utilizados, tudo depende muito das ferramentas que utiliza, o XUnit por exemplo possui um √≥timo suporte a Fixture Collections e resolve com eleg√¢ncia esta quest√£o (confira implementa√ß√£o no meu projeto).

Escrever testes √© preciso, mas como validar se a cobertura de c√≥digo est√° boa?
Ferramentas de Code Coverage servem para validar se o seus testes est√£o cobrindo bem todo seu c√≥digo. N√£o adianta dizer que tem mais de 5.000 testes se estes est√£o cobrindo apenas 50% do seu c√≥digo.

Isso significa que metade do seu c√≥digo corre o risco de ter bugs ou at√© pior, significa que numa manuten√ß√£o de rotina voc√™ pode mandar um bug para produ√ß√£o por que os testes n√£o est√£o validando partes da sua aplica√ß√£o.

O Visual Studio possui uma √≥tima ferramenta de Code Coverage, mas s√≥ est√° dispon√≠vel para as vers√µes mais completas. Mas n√£o se preocupe existem boas alternativas.

NCrunch

O NChunch re√∫ne diversas ferramentas para atender nossas necessidades

Code coverage
M√©tricas de performance
Detalhes das exceptions
Execu√ß√£o inteligente dos testes
NDepend

O NDepend possui ferramentas mais avan√ßadas que s√£o muito importantes para quem leva teste de unidade a s√©rio e possui processos de integra√ß√£o cont√≠nua, automatiza√ß√£o de build e etc.

Ferramentas Gratuitas

Algumas destas features que citei podem ser obtidas separadamente atrav√©s de outras ferramentas, √© quest√£o de buscar e testar!

Uma que eu recomendo √© o OpenCover que faz o Code Coverage para qualquer vers√£o do Visual Studio.

Dicas sobre testes
Testar √© necess√°rio. Leia, treine, pratique! O ‚Äútooling‚Äù s√≥ desenvolve que bota a m√£o na massa. Aprenda a testar, aplique esta pr√°tica no dia-a-dia e mostre aos seus colegas de trabalho que as vantagens s√£o muito grandes.

Uma √≥tima sensa√ß√£o √© ver um teste falhar ap√≥s efetuar uma manuten√ß√£o e pensar:
‚ÄúPoxa! Eu teria deixado esse bug escapar! Mais um problema evitado!‚Äù

Ap√≥s dominar o processo de escrever bons testes de unidade coloque o TDD em pr√°tica e comece a escrever c√≥digo limpo, desacoplado e test√°vel!

Recomendo dois livros para quem quiser aprender TDD, sugiro ler nesta mesma ordem.

Teste e Design no Mundo Real com .NET
Test Driven Development: By Example